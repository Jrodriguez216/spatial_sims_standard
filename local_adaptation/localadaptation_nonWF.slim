initialize() {
    
    initializeSLiMModelType("nonWF");
    initializeSLiMOptions(keepPedigrees=T, dimensionality="xy");
    //initializeTreeSeq();  
    
    defaults = Dictionary(
        "SEED", getSeed(),
        "SD", 0.5,       // sigma_D, dispersal distance
        "SC", 0.3,       // sigma_C, competition distance parameter 
        "SM", 0.3,       // sigma_M, Mate choice distance parameter
        "SK", 0.7,       // sigma_K, standard deviation of the fitness function
        "K", 100,        // carrying capacity per unit area
        "M", 1e-8,      // mutation rate
        "LIFETIME", 4,   // average life span
        "WIDTH", 5.0,    // width of the simulated area
        "HEIGHT", 5.0,   // height of the simulated area
        "RUNTIME", 10000,  // total number of ticks to run the simulation for 
        "env_image", "./LAimg_greyscale.png",  // image in
        "R", 1e-8        // recombination rate
        );
    
    // Set up parameters with a user-defined function
    setupParams(defaults);    
    
    initializeMutationRate(c(0.0, M, 0.0), c(4e5 - 1, 6e5 - 1, 1e6 - 1));
    initializeMutationType("m1", 0.0, "f", 0.0); // neutral
    initializeMutationType("m2", 0.5, "n", 0.0, 0.05); // QTL
     
    m2.convertToSubstitution = F;
    
    
    // Set up constants that depend on externally defined parameters
    defineConstant("FECUN", 1 / LIFETIME);
    defineConstant("RHO", FECUN / ((1 + FECUN) * K));
    defineConstant("PARAMS", defaults);
    
    initializeGenomicElementType("g0", c(m1), c(1)); // id, mutationtype, proportion 
    initializeGenomicElementType("g1", c(m2), c(1)); // id, mutationtype, proportion 
    initializeGenomicElement(g0, 0, 4e5 - 1);
    initializeGenomicElement(g1, asInteger(4e5), 6e5 - 1); 
    initializeGenomicElement(g0, asInteger(6e5), 1e6 - 1);
    initializeRecombinationRate(R);
    // competition
    initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SC * 3);
    i1.setInteractionFunction("n", 1.0, SC);
    // mate choice
    initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SM * 3);
    i2.setInteractionFunction("n", 1.0, SM);
}

mutationEffect(m2) { return 1.0; }
1 first() {
    sim.addSubpop("p1", asInteger(K * WIDTH * WIDTH));
    p1.setSpatialBounds(c(0.0, 0.0, WIDTH, WIDTH));
    p1.individuals.setSpatialPosition(p1.pointUniform(p1.individualCount));
    p1.individuals.z = 0.0;
    mapImage = Image(env_image);
    
    // mapImage.floatK for greyscale images, mapImage.floatG for RGB -- better to use gs
    map = p1.defineSpatialMap("map1", "xy", 1.0 - mapImage.floatK,
		  valueRange=c(0.0, 1.0), colors=c("red", "yellow"))
		  .rescale(-1, 1);
    defineConstant("OPTIMUM", map);
}

early() {
    // Disperse offspring
    offspring = p1.subsetIndividuals(maxAge=0);
    p1.deviatePositions(offspring, "reprising", INF, "n", SD);
    
    // Measure local density and use it for density regulation
    i1.evaluate(p1);
    inds = p1.individuals;
    competition = i1.localPopulationDensity(inds);
    inds.fitnessScaling = 1 / (1 + RHO * competition);

    // construct phenotypes and fitness effects from QTLs
    inds = sim.subpopulations.individuals;
    phenotype = inds.sumOfMutationsOfType(m2);
    location = inds.spatialPosition;
    optimum = OPTIMUM.mapValue(location);
    
    qtl_fit = 1 + dnorm(phenotype, optimum, SK);
    qtl_fit = qtl_fit/max(qtl_fit);
    
    inds.fitnessScaling =   inds.fitnessScaling * qtl_fit;
    inds.tagF = optimum;
    
    // color individuals according to phenotype
    inds.color = OPTIMUM.mapColor(phenotype);
        
    if (p1.individualCount == 0) {
        catn("Population went extinct! Ending the simulation.");
        sim.simulationFinished();
    }
}

2: first() {
    // evaluate mate choice in preparation for reproduction
    i2.evaluate(p1);
    print(sim.chromosome.mutationRates);
}

first() {
    // preparation for the reproduction() callback
    i2.evaluate(p1);
}

reproduction() {
    // spatial mate choice
    mate = i2.drawByStrength(individual, 1);
    if (mate.size()){;
        subpop.addCrossed(individual, mate, count=rpois(1, FECUN));
    }
    return;
}

RUNTIME late() {
    
    // assign tag values to be preserved
    inds = sortBy(sim.subpopulations.individuals, "pedigreeID");
    phenotype = inds.sumOfMutationsOfType(m2);
    location = inds.spatialPosition;
    optimum = OPTIMUM.mapValue(location);
    // record tag values and pedigree IDs in metadata
    metadataDict = Dictionary("optimum", optimum, "phenotype", phenotype, "ids", inds.pedigreeID, "defaults", defaults);
    //sim.treeSeqOutput("./localadaptationSLiM.trees", metadata=metadataDict);
    sim.simulationFinished();
}


function (void)setupParams(object<Dictionary>$ defaults)
{
    if (!exists("PARAMFILE")) defineConstant("PARAMFILE", "./params.json");
    if (!exists("OUTDIR")) defineConstant("OUTDIR", ".");
    defaults.addKeysAndValuesFrom(Dictionary("PARAMFILE", PARAMFILE, "OUTDIR", OUTDIR));
    
    if (fileExists(PARAMFILE)) {
        defaults.addKeysAndValuesFrom(Dictionary(readFile(PARAMFILE)));
        defaults.setValue("READ_FROM_PARAMFILE", PARAMFILE);
    }
    
    defaults.setValue("OUTBASE", OUTDIR + "/out_" + defaults.getValue("SEED"));
    defaults.setValue("OUTPATH", defaults.getValue("OUTBASE") + ".trees");
    
    for (k in defaults.allKeys) {
        if (!exists(k))
            defineConstant(k, defaults.getValue(k));
        else
            defaults.setValue(k, executeLambda(k + ";"));
    }
}